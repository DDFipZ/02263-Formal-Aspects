NET
	
scheme TIMETABLE = 
  extend NET with 
  class 
    type 
      TimeTable = TramId -m-> Plan, -- the empty timetable
      Plan = (StopId >< Time >< Time)-list,-- add to a time table an empty plan for a new tram
      TramId = Text 
    	 
    value /* generators */
      addTram : TramId >< TimeTable -> TimeTable
      -- add a stop with arrival time and departure time to the plan for
      -- a given tram 
      addTram(tramid, tt) is tt !! [tramid +> <..>], 
      	
      addStop : TramId >< StopId >< Time >< Time >< TimeTable -> TimeTable
      addStop(tramid, stopid, t1, t2, tt) is 
        tt !! [tramid +> tt(tramid) ^ <.(stopid, t1, t2).>] 
    	 
    value /* observers */ 
      
      isIn : TramId >< TimeTable -> Bool
        -- check whether a tram with a given name exists in a given time
        -- table  
      isIn(tramid, tt) is (exists ti : TramId :- ti isin dom tt /\ ti = tramid), 
      	 
      -- you can add more observers here  
      isTimetableNotEmpty : TimeTable -> Bool
      -- Checks for existing tram_ids and for each tram to have a non-empty plan
      isTimetableNotEmpty(tt) is 
        (all plan : Plan :- plan isin rng tt =>
          len (plan) > 0)
          /\ card (dom tt) > 0,
      	
      allStopsInPlanExistsInNet : TimeTable >< Net -> Bool
      allStopsInPlanExistsInNet(tt, n) is 
        (all plan : Plan :- 
           plan isin rng tt => 
             (all (stopid, at, dt) : StopId >< Time >< Time :- 
                (stopid, at, dt) isin plan => isIn(stopid, n))), 
      	
      planStopsDirectlyConnected : TimeTable >< Net -> Bool
      planStopsDirectlyConnected(tt, n) is 
        (all tram : TramId :- 
           tram isin dom tt => 
           let
            (stopid1, at1, dt1) = hd (tt(tram)),
            list_tail = tl (tt(tram))
           in
            checkConsecutiveStops(list_tail,n, (stopid1, at1, dt1))
           end
        ),
      	
      checkConsecutiveStops : Plan >< Net >< (StopId >< Time >< Time) -> Bool
      checkConsecutiveStops(planlist, n, (stopid, at, dt)) is 
        let
          (stopid1, at1, dt1) = hd (planlist),
          newlist = tl (planlist) in 
          if ~areDirectlyConnected(stopid, stopid1, n) then false 
          else 
            if len (newlist) = 0 then true 
            else checkConsecutiveStops(newlist, n, (stopid1, at1, dt1)) 
            end 
          end 
        end,

      checkArrivalTimeLessThanDepature : TimeTable -> Bool 
      checkArrivalTimeLessThanDepature(t) is
        (all tram : TramId :- tram isin dom t => 
        (all (s, at, dt) : (StopId >< Time >< Time) :- (s, at, dt) isin t(tram) => at < dt)),
      
      drivingTimeIncrement : TimeTable >< Net -> Bool
      drivingTimeIncrement(tt, n) is 
        (all tram : TramId :- 
            tram isin dom tt => checkDrivingTimeIncrement(tt(tram), ("", 0 ,0), n)),
    
      checkDrivingTimeIncrement : Plan >< (StopId >< Time >< Time) >< Net -> Bool
      checkDrivingTimeIncrement(planlist, (stopid, at, dt), n) is
      let (stopid1, at1, dt1) = hd (planlist), newlist = tl (planlist), drt = minDrivingTime(stopid, stopid1, n) in
          if  (at1 - dt) < drt then false 
          else 
            if len (newlist) = 0 then true 
            else checkDrivingTimeIncrement(newlist, (stopid1, at1, dt1), n) 
            end 
          end 
        end, 
      
      correctHeadwayBetweenTrams : TimeTable >< Net-> Bool
      correctHeadwayBetweenTrams(tt, n) is
      (all tram1 : TramId :- tram1 isin dom tt =>
        (all tram2 : TramId :- tram2 isin {trams | trams : TramId :- trams isin dom tt /\ trams ~= tram1} =>
          let
            (stopid1, at1, dt1) = hd (tt(tram1)),
            (stopid2, at2, dt2) = hd (tt(tram2)),
            list_tail1 = tl (tt(tram1)),
            list_tail2 = tl (tt(tram2))
            
          in
            checkHeadwayBetweenTrams(list_tail1, (stopid1, at1, dt1), list_tail2, (stopid2, at2, dt2), n)
          end
        )
      ),

      checkHeadwayBetweenTrams : Plan >< (StopId >< Time >< Time) >< Plan >< (StopId >< Time >< Time) >< Net -> Bool 
      checkHeadwayBetweenTrams(plan1, (stopid1, at1, dt1), plan2, (stopid2, at2, dt2), n) is
        let
          (stopid_1, at_1, dt_1) = hd (plan1),
          (stopid_2, at_2, dt_2) = hd (plan2),
          list_tail1 = tl (plan1),
          list_tail2 = tl (plan2)
        in

            if stopid1 = stopid2 /\ stopid_1 = stopid_2 /\ ((abs(dt1 - dt2) < minHeadway(stopid1, stopid_1, n)) \/ (abs(at_1 - at_2) < minHeadway(stopid1, stopid_1, n))) then false
            else
              if len(list_tail1) = 0 \/ len(list_tail2) = 0 then true
              else
                checkHeadwayBetweenTrams(list_tail1, (stopid_1, at_1, dt_1), list_tail2, (stopid_2, at_2, dt_2), n)
              end
            end       
        end
      
      

      
      

    value /* predicates to check time tables */   
      isWellformed : TimeTable >< Net -~-> Bool
      isWellformed(t, n) is false   	 

  end
