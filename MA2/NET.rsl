scheme NET =
class
  type 
    Net = Stop -m-> Connection-set, -- tram nets
    Headway = Time, -- minimum headways
    DrivingTime = Time, -- minimum driving times
    Time = Nat, -- times in number of minutes
    Capacity = Nat, -- capacities
    Connection = Stop >< Stop >< Capacity >< Headway >< DrivingTime,
    Stop = StopId >< Capacity, --Stops
    StopId = Text  -- names of stops
  value /* generators */
    empty :  Net = []  -- the empty net

    
    -- insert a stop with a given name and capacity 
    -- -- Create the Stop object and make it a key to an empty value and return the new Net
    -- insertStop : StopId >< Capacity >< Net -> Net
    -- ...,

    -- -- add a connection between given stops, 
    -- -- with the given minimum headway, capacity and minimum driving time
    -- -- 1. Check if the stops are in the map.
    -- -- 2. If so add a connection value to each of the stops
    -- addConnection : StopId >< StopId >< Headway >< Capacity >< DrivingTime >< Net -> Net
    -- ... 
  value /* observers */
    -- check whether a stop is in a network     
    isIn : StopId >< Net -> Bool
    isIn(stopid, net) is 
      (exists (si, capacity) : Stop :- (si, capacity) isin dom net /\ si = stopid),
 
    -- get the capacity of a stop 
    capacity : StopId >< Net -~-> Capacity
    capacity(stopid, net) is
      hd({capacity | (si, capacity) : Stop :- (si, capacity) isin dom net}),

    getStop : StopId >< Net -~-> Stop
    getStop(stopid, net) is
      hd({(si, net) | (si, net) : Stop :- (si, net) isin dom net /\ si = stopid}),

    -- check whether two stops are directly connected in a network        
    areDirectlyConnected : StopId >< StopId >< Net -> Bool
    areDirectlyConnected(stopid1, stopid2, net) is 
      stopid2 isin {stopid_2 | (stop1, (stopid_2, c2),  c, h, dt) : Connection :- (stop1, (stopid_2, c2), c, h, dt) isin net(getStop(stopid1, net))}
      /\
      stopid1 isin {stopid_2 | (stop1, (stopid_2, c2),  c, h, dt) : Connection :- (stop1, (stopid_2, c2), c, h, dt) isin net(getStop(stopid2, net))}


    -- get minimum headway between two connected stops        
    minHeadway : StopId >< StopId >< Net -~-> Headway
    ..., 

  --  -- get the capacity for a connection between two connected stops
  --   capacity : StopId >< StopId >< Net -~-> Capacity
  --   ...,
 
  --   -- get minimum driving time between two connected stops        
  --   minDrivingTime : StopId >< StopId >< Net -~-> DrivingTime
  --   ...

 
  -- value /* predicates to check nets */
  --   isWellformed : Net -> Bool
  --   isWellformed(n) is ...

  -- test values
  value
    -- Beach <-> Stop <-> Post
    testMap :  Net = [
      ("Stop", 2) +> {
        (("Stop", 2), ("Post", 3), 5, 7, 9),
        (("Stop", 2), ("Beach", 4), 6, 8 ,10)
      },
      ("Post", 3) +> {(("Post", 3), ("Stop", 2), 5, 7, 9)},
      ("Beach", 4) +> {(("Beach", 4), ("Stop", 2), 6, 8 ,10)}
      ]
  test_case
    [isInTest1] ~isIn("Stawdawdop", testMap),
    [isInTest2] isIn("Stop", testMap),

    [getCapicity1] capacity("Stop", testMap) = 4,

    [getStop1] getStop("Stop", testMap) = ("Stop", 2),
    [getStop2] getStop("Post", testMap) ~= ("Stop", 2),

    [areDirectlyConnected1] ~areDirectlyConnected("Post", "Beach", testMap),
    [areDirectlyConnected2] areDirectlyConnected("Stop", "Beach", testMap)


    
end  
