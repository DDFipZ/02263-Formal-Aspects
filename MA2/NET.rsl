scheme NET = 
  class 
    type
      -- given
      Net = Stop -m-> Connection-set, -- tram nets
      Headway = Time, -- minimum headways
      DrivingTime = Time, -- minimum driving times
      Time = Nat, -- times in number of minutes
      Capacity = Nat, -- capacities
      StopId = Text, -- names of stops

      -- own
      Connection = Stop >< Stop >< Capacity >< Headway >< DrivingTime, 
      Stop = StopId >< Capacity --Stops
    value /* generators */ 
      empty : Net = [], -- the empty net
      
      insertStop : StopId >< Capacity >< Net -> Net
        -- insert a stop with a given name and capacity 
        -- -- Create the Stop object and make it a key to an empty value
        -- and return the new Net
      insertStop(id, c, net) is net !! [(id, c) +> {}], 
        -- -- add a connection between given stops, 
        -- -- with the given minimum headway, capacity and minimum driving
        -- time
        -- -- 1. Check if the stops are in the map.
        -- -- 2. If so add a connection value to each of the stops    
      
      addConnection : 
        StopId >< StopId >< Headway >< Capacity >< DrivingTime >< Net -> Net
      addConnection(stopid_1, stopid_2, h, c, dt, net) is 
        net !! 
        [getStop(stopid_1, net) +> 
         net(getStop(stopid_1, net)) union 
         {(getStop(stopid_1, net), getStop(stopid_2, net), h, c, dt)}, 
         getStop(stopid_2, net) +> 
         net(getStop(stopid_2, net)) union 
         {(getStop(stopid_2, net), getStop(stopid_1, net), h, c, dt)}] 
    	 
    
    value /* observers */ 
      -- check whether a stop is in a network         
      isIn : StopId >< Net -> Bool
      isIn(stopid, net) is 
        (exists (si, capacity) : Stop :- 
           (si, capacity) isin dom net /\ si = stopid), 

      
      	 
      -- get the capacity of a stop     
      capacity : StopId >< Net -~-> Capacity
      capacity(stopid, net) is 
        let (s, c) = getStop(stopid, net) in
          c 
      	end,
        getStopSet : StopId >< Net -> Stop-set
      getStopSet(stopid, n) is
      {(si, c) | (si, c) : Stop :- (si, c) isin dom n /\ si = stopid},

      getStop : StopId >< Net -~-> Stop
      getStop(stopid, net) is
        hd(getStopSet(stopid, net)) 
        pre getStopSet(stopid, net) ~= {},
      
      
      	 
      -- check whether two stops are directly connected in a network  
      --          
      areDirectlyConnected : StopId >< StopId >< Net -> Bool
      -- Requirement one
      areDirectlyConnected(stopid1, stopid2, net) is
        isIn(stopid1, net) /\ isIn(stopid2, net) /\
        stopid2 isin 
          {stopid_2 | 
           (stop1, (stopid_2, c2), c, h, dt) : Connection :- 
             (stop1, (stopid_2, c2), c, h, dt) isin net(getStop(stopid1, net))} /\ 
        stopid1 isin 
          {stopid_2 | 
           (stop1, (stopid_2, c2), c, h, dt) : Connection :- 
             (stop1, (stopid_2, c2), c, h, dt) isin net(getStop(stopid2, net))}, 
      	 
      -- get minimum headway between two connected stops            
      minHeadway : StopId >< StopId >< Net -~-> Headway
      minHeadway(stopid1, stopid2, net) is 
        if areDirectlyConnected(stopid1, stopid2, net) 
        then 
          hd ({h | 
               (stop1, (stopid_2, c2), c, h, dt) : Connection :- 
                 (stop1, (stopid_2, c2), c, h, dt) isin 
                   net(getStop(stopid2, net))  /\ stopid_2 = stopid1}) 
        else 0 
        end, 
      	 
      --  -- get the capacity for a connection between two connected stops
      --    
      capacity : StopId >< StopId >< Net -~-> Capacity
      capacity(stopid1, stopid2, net) is 
        if areDirectlyConnected(stopid1, stopid2, net) 
        then 
          hd ({c | 
               (stop1, (stopid_2, c2), c, h, dt) : Connection :- 
                 (stop1, (stopid_2, c2), c, h, dt) isin 
                   net(getStop(stopid2, net)) /\ stopid_2 = stopid1}) 
        else 0 
        end, 
      	 
      --   -- get minimum driving time between two connected stops    
      --        
      minDrivingTime : StopId >< StopId >< Net -~-> DrivingTime
      minDrivingTime(stopid1, stopid2, net) is 
        if areDirectlyConnected(stopid1, stopid2, net) 
        then 
          hd ({dt | 
               (stop1, (stopid_2, c2), c, h, dt) : Connection :- 
                 (stop1, (stopid_2, c2), c, h, dt) isin 
                   net(getStop(stopid2, net)) /\ stopid_2 = stopid1}) 
        else 0 
        end, 
      	 
      -- value /* predicates to check nets */    
      isWellformed : Net -> Bool
      isWellformed(n) is 
        (all (id, c) : Stop :- 
           (id, c) isin dom n => 
             (all (stop1, (stopid_2, c2), c, h, dt) : Connection :- 
                (stop1, (stopid_2, c2), c, h, dt) isin n(getStop(id, n)) => 
                  areDirectlyConnected(id, stopid_2, n))) -- Requirement 1: Net connections needs to be symmetrical    
        -- test values    

    	 

  end
